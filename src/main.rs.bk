use std::fs::read_to_string;

use clap::Parser;

use reqwest::Client;
use serde::{Deserialize, Serialize};

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

#[derive(Serialize, Deserialize, Debug)]
struct Secret {
    token: String,
}

#[derive(Parser, Debug)]
struct Args {
    /// path to the secret toml file
    #[clap(short, long, default_value = "secret.toml")]
    secret: String,
}

enum Method {
    GetUpdates,
}

impl std::fmt::Display for Method {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Method::GetUpdates => "getUpdates",
            }
        )
    }
}

fn url(secret: &Secret, method: Method) -> String {
    format!("https://api.telegram.org/bot{}/{}", secret.token, method)
}

struct User {
    id: u64,
    is_bot: bool,
    first_name: String,
    last_name: Option<String>,
    username: Option<String>,
    language_code: Option<String>,
    is_premium: Option<bool>,
    added_to_attachment_menu: Option<bool>,
    can_join_groups: Option<bool>,
    can_read_all_group_messages: Option<bool>,
    supports_inline_queries: Option<bool>,
}

struct Chat {
    id: u64,
    r#type: String,
    tltle: Option<String>,
    username: Option<String>,
    first_name: Option<String>,
    last_name: Option<String>,
    photo: Option<ChatPhoto>,
    bio: Option<String>,
    has_private_forwards: Option<bool>,
    join_to_send_messages: Option<bool>,
    join_by_request: Option<bool>,
    description: Option<String>,
    invite_link: Option<String>,
    pinned_message: Option<Message>,
    permissions: Option<ChatPermissions>,
    slow_mode_delay: Option<u64>,
    message_auto_delete_time: Option<u64>,
    has_protected_content: Option<bool>,
    sticker_set_name: Option<String>,
    can_set_sticker_set: Option<bool>,
    linked_chat_id: Option<u64>,
    location: Option<ChatLocation>,
}

struct Message {
    message_id: u64,
    from: Option<User>,
    sender_chat: Option<Chat>,
    data: u64,
    chat: Chat,
    forward_from: Option<User>,
    forward_from_chat: Option<Chat>,
    forward_from_message_id: Option<u64>,
    forward_signature: String,
    forward_sender_name: String,
    forward_date: u64,
    is_automatic_forward: bool,
    reply_to_message: Message,
    via_bot: User,
    edit_date: u64,
    has_protected_content: bool,
    media_group_id: String,
    author_signature: String,
    text: String,
    entities: Vec<MessageEntity>,
    animation: Animation,
    audio: Audio,
    document: Document,
    photo: Vec<PhotoSize>,
    sticker: Sticker,
    video: Video,
    video_note: VodeoNote,
    voice: Voice,
    caption: String,
    caption_entities: Vec<MessageEntity>,
    contact: Contact,
    dice: Dice,
    game: Game,
    poll: Poll,
    venue: Venue,
    location: Location,
    new_chat_members: Vec<User>,
    left_chat_member: User,
    new_chat_title: String,
    new_chat_photo: Vec<PhothSize>,
    delete_chat_photo: bool,
    group_chat_created: bool,
    supergroup_chat_created: bool,
    channel_chat_created: bool,
    message_auto_delete_timer_changed:MessageAutoDeleteTimerChangedm
    migrate_to_chat_id:u64,
    migrate_from_chat_id:u64,
    pinned_message:Message,
    invoice:Invoice,
    successful_payment:SuccessfulPayment
}

struct Update {
    update_id: u64,
    from: User,
    sender_chat: Chat,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    let secret = read_to_string(&args.secret)?;
    let secret = toml::from_str(&secret)?;

    println!("{:?}", args);

    println!("{}", url(&secret, Method::GetUpdates));

    let client = Client::new();

    let rsp = client.post(url(&secret, Method::GetUpdates)).send().await?;

    println!("rsp: {:?}", rsp);
    // println!("rsp: {:?}", rsp.bytes().await);

    println!(
        "rsp: {:?}",
        rsp.json::<std::collections::HashMap<String, String>>()
            .await
    );

    Ok(())
}
